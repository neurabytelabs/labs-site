<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraByte Labs - Experimental Projects</title>
    <meta name="description" content="Explore cutting-edge AI and software experiments from NeuraByte Labs">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- GSAP for micro-interactions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <!-- Three.js for shader animations -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <style>
        /* ═══════════════════════════════════════════════════════════════════
           NEURABYTE LABS v9.0 - USER-FRIENDLY REDESIGN
           Clean, scrollable, professional
           ═══════════════════════════════════════════════════════════════════ */

        :root {
            --color-bg: #0a0a0b;
            --color-surface: #111113;
            --color-surface-hover: #18181b;
            --color-border: rgba(255, 255, 255, 0.08);
            --color-border-hover: rgba(251, 191, 36, 0.3);
            --color-text: #fafafa;
            --color-text-muted: #a1a1aa;
            --color-text-dim: #71717a;
            --color-accent: #fbbf24;
            --color-accent-hover: #fde68a;
            --color-live: #22c55e;
            --color-dev: #f97316;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --shadow-card: 0 4px 24px rgba(0, 0, 0, 0.4);
            --shadow-card-hover: 0 12px 48px rgba(0, 0, 0, 0.6), 0 0 0 1px var(--color-border-hover);
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-smooth: 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.6;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ═══ HEADER ═══ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 16px 24px;
            background: rgba(10, 10, 11, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--color-border);
            transition: var(--transition-fast);
        }

        .header-inner {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: var(--color-text);
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--color-accent), #f97316);
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo-text {
            font-weight: 600;
            font-size: 1.1rem;
            letter-spacing: -0.02em;
        }

        .logo-text span {
            color: var(--color-accent);
        }

        .nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-link {
            padding: 8px 16px;
            color: var(--color-text-muted);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            border-radius: var(--radius-sm);
            transition: var(--transition-fast);
        }

        .nav-link:hover {
            color: var(--color-text);
            background: var(--color-surface);
        }

        .nav-cta {
            background: var(--color-accent);
            color: #000;
            font-weight: 600;
        }

        .nav-cta:hover {
            background: var(--color-accent-hover);
            color: #000;
        }

        /* ═══ HERO SECTION ═══ */
        .hero {
            padding: 140px 24px 80px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 400px;
            background: radial-gradient(ellipse, rgba(251, 191, 36, 0.08) 0%, transparent 70%);
            pointer-events: none;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 100px;
            font-size: 0.8rem;
            color: var(--color-text-muted);
            margin-bottom: 24px;
        }

        .hero-badge-dot {
            width: 6px;
            height: 6px;
            background: var(--color-live);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hero-title {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 700;
            letter-spacing: -0.03em;
            line-height: 1.1;
            margin-bottom: 20px;
        }

        .hero-title span {
            background: linear-gradient(135deg, var(--color-accent), #f97316);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero-subtitle {
            font-size: 1.2rem;
            color: var(--color-text-muted);
            max-width: 600px;
            margin: 0 auto 40px;
            line-height: 1.7;
        }

        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 48px;
            flex-wrap: wrap;
        }

        .hero-stat {
            text-align: center;
        }

        .hero-stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--color-accent);
        }

        .hero-stat-label {
            font-size: 0.85rem;
            color: var(--color-text-dim);
            margin-top: 4px;
        }

        /* ═══ PROJECTS SECTION ═══ */
        .projects {
            padding: 60px 24px 120px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 40px;
            flex-wrap: wrap;
            gap: 16px;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .section-filter {
            display: flex;
            gap: 8px;
        }

        .filter-btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            color: var(--color-text-muted);
            font-size: 0.85rem;
            font-family: var(--font-sans);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .filter-btn:hover, .filter-btn.active {
            background: var(--color-surface);
            border-color: var(--color-border-hover);
            color: var(--color-text);
        }

        /* ═══ CARD GRID ═══ */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 24px;
        }

        /* ═══ PROJECT CARD ═══ */
        .project-card {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            cursor: grab;
            transition: var(--transition-smooth);
            will-change: transform, box-shadow;
        }

        .project-card:hover {
            border-color: var(--color-border-hover);
            box-shadow: var(--shadow-card-hover);
        }

        .project-card:active {
            cursor: grabbing;
        }

        .project-card.is-dragging {
            z-index: 10;
        }

        /* Card Scene (Shader Animation) */
        .card-scene {
            width: 100%;
            height: 180px;
            position: relative;
            overflow: hidden;
            background: linear-gradient(180deg, var(--color-surface) 0%, var(--color-bg) 100%);
        }

        .card-canvas {
            width: 100%;
            height: 100%;
            min-width: 280px;
            min-height: 180px;
            display: block;
            background: var(--color-bg);
        }

        .scene-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to top, var(--color-surface), transparent);
            pointer-events: none;
        }

        /* Card Body */
        .card-body {
            padding: 20px 24px 24px;
        }

        .card-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .card-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 100px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .card-status.live {
            background: rgba(34, 197, 94, 0.15);
            color: var(--color-live);
        }

        .card-status.dev {
            background: rgba(249, 115, 22, 0.15);
            color: var(--color-dev);
        }

        .card-status-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: currentColor;
        }

        .card-category {
            font-size: 0.75rem;
            color: var(--color-text-dim);
            font-weight: 500;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            margin-bottom: 8px;
            color: var(--color-text);
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--color-text-muted);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .card-tech {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 20px;
        }

        .tech-tag {
            padding: 4px 10px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-family: var(--font-mono);
            color: var(--color-accent);
        }

        .card-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .card-launch {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: var(--color-accent);
            color: #000;
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 600;
            border-radius: var(--radius-sm);
            transition: var(--transition-fast);
        }

        .card-launch:hover {
            background: var(--color-accent-hover);
            transform: translateY(-1px);
        }

        .card-launch.disabled {
            background: var(--color-surface-hover);
            color: var(--color-text-dim);
            cursor: not-allowed;
            pointer-events: none;
        }

        .card-launch-arrow {
            transition: transform var(--transition-fast);
        }

        .card-launch:hover .card-launch-arrow {
            transform: translateX(4px);
        }

        /* ═══ FOOTER ═══ */
        .footer {
            padding: 40px 24px;
            border-top: 1px solid var(--color-border);
            text-align: center;
        }

        .footer-text {
            font-size: 0.85rem;
            color: var(--color-text-dim);
        }

        .footer-text a {
            color: var(--color-accent);
            text-decoration: none;
        }

        .footer-text a:hover {
            text-decoration: underline;
        }

        /* ═══ RESPONSIVE ═══ */
        @media (max-width: 768px) {
            .header {
                padding: 12px 16px;
            }

            .nav {
                display: none;
            }

            .hero {
                padding: 120px 16px 60px;
            }

            .hero-stats {
                gap: 24px;
            }

            .projects {
                padding: 40px 16px 80px;
            }

            .card-grid {
                grid-template-columns: 1fr;
            }

            .card-scene {
                height: 140px;
            }
        }

        /* ═══ SCROLL ANIMATIONS ═══ */
        .card-grid .project-card {
            opacity: 0;
            transform: translateY(30px);
        }

        .card-grid .project-card.visible {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-inner">
            <a href="/" class="logo">
                <div class="logo-icon">N</div>
                <div class="logo-text">NeuraByte <span>Labs</span></div>
            </a>
            <nav class="nav">
                <a href="#projects" class="nav-link">Projects</a>
                <a href="https://neurabytelabs.com" class="nav-link" target="_blank">Main Site</a>
                <a href="https://github.com/mrsarac" class="nav-link nav-cta" target="_blank">GitHub</a>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-badge">
            <span class="hero-badge-dot"></span>
            Experimental Projects
        </div>
        <h1 class="hero-title">
            Building the <span>Future</span><br>of Intelligence
        </h1>
        <p class="hero-subtitle">
            A collection of experimental AI projects, tools, and research from NeuraByte Labs.
            Each project pushes the boundaries of what's possible.
        </p>
        <div class="hero-stats">
            <div class="hero-stat">
                <div class="hero-stat-value">8</div>
                <div class="hero-stat-label">Projects</div>
            </div>
            <div class="hero-stat">
                <div class="hero-stat-value">5</div>
                <div class="hero-stat-label">Live</div>
            </div>
            <div class="hero-stat">
                <div class="hero-stat-value">3</div>
                <div class="hero-stat-label">In Development</div>
            </div>
        </div>
    </section>

    <!-- Projects Section -->
    <section class="projects" id="projects">
        <div class="section-header">
            <h2 class="section-title">All Projects</h2>
            <div class="section-filter">
                <button class="filter-btn active" data-filter="all">All</button>
                <button class="filter-btn" data-filter="live">Live</button>
                <button class="filter-btn" data-filter="dev">In Dev</button>
            </div>
        </div>

        <div class="card-grid" id="card-grid">
            <!-- Cards will be generated by JavaScript -->
        </div>
    </section>

    <!-- Footer -->
    <footer class="footer">
        <p class="footer-text">
            2025 NeuraByte Labs. Built with passion by <a href="https://mustafasarac.com" target="_blank">Mustafa Sarac</a>
        </p>
    </footer>

    <script type="module">
        import * as THREE from 'three';

        // ═══════════════════════════════════════════════════════════════════
        // PROJECT DATA
        // ═══════════════════════════════════════════════════════════════════
        const PROJECTS = [
            {
                id: 'spinozaos',
                title: 'SpinozaOS',
                category: 'Design Systems',
                description: 'Award-winning design system for the Age of Superintelligence. "More Geometrico" philosophy.',
                tech: ['Design Tokens', 'React', 'Motion'],
                status: 'live',
                url: 'https://github.com/mrsarac/spinozaos'
            },
            {
                id: 'lithosphere',
                title: 'Lithosphere',
                category: 'Physics & Visualization',
                description: 'N-body gravitational physics simulation with Newton, Artistic, and Magnetic modes.',
                tech: ['Three.js', 'WebGPU', 'Physics'],
                status: 'live',
                url: 'https://lithosphere.mustafasarac.com'
            },
            {
                id: 'boardroom',
                title: 'Cognitive Boardroom',
                category: 'AI Experiments',
                description: 'AI-powered boardroom simulator with 5 personas. System 2 thinking in action.',
                tech: ['Gemini AI', 'React', 'Real-time'],
                status: 'live',
                url: 'https://board.phinote.com'
            },
            {
                id: 'nexus',
                title: 'NEXUS AI Forge',
                category: 'Developer Tools',
                description: 'Ultimate AI-augmented developer tool. Cross-platform, Rust-powered, multi-model AI.',
                tech: ['Rust', 'Multi-AI', 'CLI'],
                status: 'live',
                url: 'https://github.com/mrsarac/NEXUS-AI-Forge'
            },
            {
                id: 'oracle',
                title: 'ORACLE Engine',
                category: 'AI Simulation',
                description: 'Strategic decision simulation platform. Gemini AI-powered scenario analysis.',
                tech: ['Gemini AI', 'Python', 'Strategy'],
                status: 'live',
                url: 'https://github.com/mrsarac/ORACLE-Engine'
            },
            {
                id: 'engram',
                title: 'Engram Memory',
                category: 'Learning & Memory',
                description: 'Cyberpunk memory prosthetic. AI-powered flashcards with FSRS spaced repetition.',
                tech: ['FSRS', 'AI', 'Cyberpunk'],
                status: 'dev',
                url: null
            },
            {
                id: 'manifesto',
                title: 'Digital Renaissance',
                category: 'Philosophy & Education',
                description: 'Manifesto for the Age of Autodidacts. AI-powered self-learning revolution.',
                tech: ['AI Education', 'Philosophy', 'Manifesto'],
                status: 'live',
                url: 'https://readwise.io/reader/shared/01kayk0tzxvfc603qbvmcwfr21/'
            },
            {
                id: 'voice',
                title: 'NeuraByte Voice',
                category: 'Native Apps',
                description: 'Zero-latency voice-to-text for macOS & iOS. Push-to-talk with premium animations.',
                tech: ['Swift', 'macOS', 'iOS'],
                status: 'dev',
                url: null
            }
        ];

        // ═══════════════════════════════════════════════════════════════════
        // SHADER SCENES - Project-specific animations
        // ═══════════════════════════════════════════════════════════════════
        const SCENE_SHADERS = {
            spinozaos: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec2 center = vUv - 0.5;
                    vec3 color = vec3(0.02, 0.02, 0.03);

                    // 8pt grid
                    float gridPulse = sin(uTime * 1.5) * 0.3 + 0.7;
                    float gridX = smoothstep(0.015, 0.0, abs(fract(vUv.x * 8.0) - 0.5));
                    float gridY = smoothstep(0.015, 0.0, abs(fract(vUv.y * 6.0) - 0.5));
                    color += vec3(0.98, 0.75, 0.14) * (gridX + gridY) * 0.1 * gridPulse;

                    // Token dots
                    for (float i = 0.0; i < 6.0; i++) {
                        float orbitRadius = 0.15 + mod(i, 3.0) * 0.08;
                        vec2 tokenPos = vec2(0.5, 0.5) + vec2(
                            cos(uTime * 0.5 + i * 1.047),
                            sin(uTime * 0.5 + i * 1.047)
                        ) * orbitRadius;
                        float token = exp(-length(vUv - tokenPos) * 40.0);
                        color += vec3(0.98, 0.75, 0.14) * token * (0.5 + uHover * 0.5);
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            lithosphere: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec2 center = vUv - 0.5;
                    vec3 color = vec3(0.01, 0.01, 0.02);

                    // Three bodies
                    vec3 colors[3];
                    colors[0] = vec3(0.98, 0.45, 0.09);
                    colors[1] = vec3(0.23, 0.51, 0.96);
                    colors[2] = vec3(0.66, 0.33, 0.97);

                    for (int i = 0; i < 3; i++) {
                        float phase = float(i) * 2.094;
                        float t = uTime * (0.5 + float(i) * 0.2);
                        vec2 pos = vec2(
                            sin(t + phase) * 0.2,
                            cos(t * 0.7 + phase) * 0.15
                        );
                        float dist = length(center - pos);
                        float body = exp(-dist * 20.0);
                        color += colors[i] * body * (0.6 + uHover * 0.4);
                    }

                    // Stars
                    for (float i = 0.0; i < 20.0; i++) {
                        vec2 starPos = vec2(
                            fract(sin(i * 12.34) * 4567.89) - 0.5,
                            fract(cos(i * 56.78) * 1234.56) - 0.5
                        );
                        float star = exp(-length(center - starPos) * 100.0);
                        color += vec3(0.9, 0.95, 1.0) * star * 0.3;
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            boardroom: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec2 center = vUv - 0.5;
                    vec3 color = vec3(0.02, 0.02, 0.03);

                    // Decision table
                    vec2 tableUv = center * vec2(1.0, 1.5);
                    float table = smoothstep(0.2, 0.15, length(tableUv));
                    color += vec3(0.98, 0.75, 0.14) * table * 0.1;

                    // 5 personas
                    vec3 pColors[5];
                    pColors[0] = vec3(0.98, 0.75, 0.14);
                    pColors[1] = vec3(0.13, 0.77, 0.37);
                    pColors[2] = vec3(0.23, 0.51, 0.96);
                    pColors[3] = vec3(0.66, 0.33, 0.97);
                    pColors[4] = vec3(0.98, 0.45, 0.09);

                    vec2 pPos[5];
                    pPos[0] = vec2(0.5, 0.8);
                    pPos[1] = vec2(0.2, 0.55);
                    pPos[2] = vec2(0.8, 0.55);
                    pPos[3] = vec2(0.25, 0.25);
                    pPos[4] = vec2(0.75, 0.25);

                    int active = int(mod(uTime * 0.5, 5.0));

                    for (int i = 0; i < 5; i++) {
                        float isActive = (i == active) ? 1.0 : 0.0;
                        float dist = length(vUv - pPos[i]);
                        float node = exp(-dist * 30.0);
                        color += pColors[i] * node * (0.4 + isActive * 0.6 + uHover * 0.3);
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            nexus: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec3 color = vec3(0.02, 0.02, 0.03);

                    // Fire at top
                    float fireY = vUv.y - 0.6;
                    if (fireY > 0.0) {
                        float flameNoise = sin(vUv.x * 20.0 + uTime * 5.0) * 0.1;
                        float flame = smoothstep(0.4, 0.0, fireY - flameNoise);
                        vec3 fireColor = mix(vec3(1.0, 0.3, 0.05), vec3(1.0, 0.7, 0.1), smoothstep(0.2, 0.0, fireY));
                        color += fireColor * flame * (0.6 + uHover * 0.4);
                    }

                    // Terminal lines
                    float lineY = fract(vUv.y * 8.0 - uTime * 0.3);
                    float line = smoothstep(0.1, 0.05, abs(lineY - 0.5)) * step(vUv.y, 0.6);
                    float lineWidth = 0.3 + sin(floor(vUv.y * 8.0 - uTime * 0.3) * 5.0) * 0.15;
                    line *= step(vUv.x, 0.1 + lineWidth) * step(0.1, vUv.x);
                    color += vec3(0.13, 0.85, 0.35) * line * 0.6;

                    // Progress bar
                    float progress = fract(uTime * 0.1);
                    float inBar = step(abs(vUv.y - 0.1), 0.02) * step(0.15, vUv.x) * step(vUv.x, 0.85);
                    float filled = step((vUv.x - 0.15) / 0.7, progress) * inBar;
                    color += vec3(0.98, 0.55, 0.1) * filled * 0.8;

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            oracle: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec2 center = vUv - 0.5;
                    float dist = length(center);
                    vec3 color = vec3(0.02, 0.01, 0.04);

                    // Eye
                    float eyePulse = sin(uTime * 2.0) * 0.02;
                    float eye = smoothstep(0.15 + eyePulse, 0.1 + eyePulse, dist);
                    float pupil = exp(-dist * 20.0);
                    color += vec3(0.55, 0.36, 0.96) * eye * (0.5 + uHover * 0.5);
                    color += vec3(0.1, 0.05, 0.2) * pupil;

                    // Rays
                    float angle = atan(center.y, center.x);
                    for (float i = 0.0; i < 8.0; i++) {
                        float a = i * 0.785 + uTime * 0.2;
                        float beam = smoothstep(0.1, 0.0, abs(mod(angle + a, 0.785) - 0.3925));
                        beam *= smoothstep(0.15, 0.25, dist) * smoothstep(0.5, 0.3, dist);
                        color += vec3(0.98, 0.75, 0.14) * beam * 0.3;
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            engram: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec2 center = vUv - 0.5;
                    vec3 color = vec3(0.02, 0.02, 0.04);

                    // Memory cards floating
                    for (float i = 0.0; i < 5.0; i++) {
                        float phase = i * 1.257;
                        vec2 cardPos = vec2(0.5, 0.5) + vec2(
                            cos(uTime * 0.3 + phase),
                            sin(uTime * 0.2 + phase)
                        ) * (0.15 + i * 0.05);

                        vec2 cardUv = (vUv - cardPos) * 10.0;
                        float card = smoothstep(0.1, 0.0, max(abs(cardUv.x) - 0.8, abs(cardUv.y) - 0.5));

                        vec3 cardColor = i < 2.0 ? vec3(0.0, 1.0, 1.0) : vec3(1.0, 0.0, 0.6);
                        color += cardColor * card * 0.3 * (0.6 + uHover * 0.4);
                    }

                    // Brain node
                    float brain = exp(-length(center) * 10.0);
                    color += vec3(0.8, 0.2, 0.9) * brain * 0.6;

                    // Scanline
                    float scan = smoothstep(0.02, 0.0, abs(fract(vUv.y * 2.0 - uTime * 0.3) - 0.5));
                    color += vec3(0.0, 1.0, 0.8) * scan * 0.1;

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            manifesto: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec3 color = vec3(0.04, 0.035, 0.03);

                    // Parchment texture
                    color += vec3(0.02) * sin(vUv.x * 50.0) * sin(vUv.y * 50.0);

                    // Book pages
                    float leftPage = step(0.1, vUv.x) * step(vUv.x, 0.48) * step(0.15, vUv.y) * step(vUv.y, 0.85);
                    float rightPage = step(0.52, vUv.x) * step(vUv.x, 0.9) * step(0.15, vUv.y) * step(vUv.y, 0.85);
                    color += vec3(0.99, 0.96, 0.90) * leftPage * 0.15;
                    color += vec3(0.98, 0.95, 0.88) * rightPage * 0.12;

                    // Drop cap
                    vec2 dropCapPos = vec2(0.18, 0.7);
                    float dropCap = smoothstep(0.1, 0.06, length(vUv - dropCapPos));
                    float goldPulse = sin(uTime * 2.0) * 0.2 + 0.8;
                    color += vec3(0.98, 0.75, 0.14) * dropCap * 0.5 * goldPulse * (0.7 + uHover * 0.3);

                    // Text lines
                    for (float i = 2.0; i < 8.0; i++) {
                        float lineY = 0.75 - i * 0.06;
                        float line = smoothstep(0.008, 0.003, abs(vUv.y - lineY));
                        line *= step(0.14, vUv.x) * step(vUv.x, 0.4) * leftPage;
                        color += vec3(0.3, 0.2, 0.1) * line * 0.3;
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            voice: `
                uniform float uTime;
                uniform float uHover;
                varying vec2 vUv;

                void main() {
                    vec2 center = vUv - 0.5;
                    vec3 color = vec3(0.02, 0.02, 0.04);

                    // Central microphone
                    float mic = exp(-length(center) * 12.0);
                    color += vec3(0.98, 0.75, 0.14) * mic * (0.8 + uHover * 0.4);

                    // Sound waves
                    for (float i = 1.0; i < 5.0; i++) {
                        float radius = i * 0.08;
                        float wave = sin(uTime * 3.0 - i * 0.5);
                        float ring = smoothstep(0.02, 0.0, abs(length(center) - radius - wave * 0.02));
                        float fade = 1.0 - i / 5.0;
                        color += vec3(0.55, 0.36, 0.96) * ring * fade * 0.5;
                    }

                    // Frequency bars
                    for (float i = 0.0; i < 7.0; i++) {
                        float x = -0.3 + i * 0.1;
                        float h = 0.06 + sin(uTime * 4.0 + i * 1.2) * 0.04;
                        float bar = smoothstep(0.02, 0.01, abs(center.x - x));
                        bar *= step(-0.3, center.y) * step(center.y, -0.3 + h);
                        color += mix(vec3(0.55, 0.36, 0.96), vec3(0.23, 0.51, 0.96), i / 7.0) * bar * 0.6;
                    }

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };

        const VERTEX_SHADER = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // ═══════════════════════════════════════════════════════════════════
        // CARD SCENE RENDERER
        // ═══════════════════════════════════════════════════════════════════
        class CardScene {
            constructor(canvas, projectId) {
                this.canvas = canvas;
                this.projectId = projectId;
                this.isHovered = false;
                this.hoverValue = 0;

                this.init();
            }

            init() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: true
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uHover: { value: 0 }
                    },
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: SCENE_SHADERS[this.projectId] || SCENE_SHADERS.spinozaos
                });

                const geometry = new THREE.PlaneGeometry(2, 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.scene.add(this.mesh);

                this.resize();
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                const width = rect.width || 340;
                const height = rect.height || 180;
                this.canvas.width = width * window.devicePixelRatio;
                this.canvas.height = height * window.devicePixelRatio;
                this.renderer.setSize(width, height, false);
            }

            update(time) {
                // Smooth hover
                const target = this.isHovered ? 1 : 0;
                this.hoverValue += (target - this.hoverValue) * 0.1;

                this.material.uniforms.uTime.value = time;
                this.material.uniforms.uHover.value = this.hoverValue;

                this.renderer.render(this.scene, this.camera);
            }

            dispose() {
                this.renderer.dispose();
                this.material.dispose();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // MAIN APPLICATION
        // ═══════════════════════════════════════════════════════════════════
        class LabsApp {
            constructor() {
                this.cardGrid = document.getElementById('card-grid');
                this.scenes = new Map();
                this.currentFilter = 'all';

                this.init();
            }

            init() {
                this.renderCards();
                this.setupFilters();
                this.setupScrollAnimations();
                this.animate();
            }

            renderCards() {
                this.cardGrid.innerHTML = '';

                PROJECTS.forEach((project, index) => {
                    const card = this.createCard(project, index);
                    this.cardGrid.appendChild(card);
                });
            }

            createCard(project, index) {
                const card = document.createElement('article');
                card.className = 'project-card';
                card.dataset.status = project.status;
                card.dataset.index = index;

                card.innerHTML = `
                    <div class="card-scene">
                        <canvas class="card-canvas" data-project="${project.id}"></canvas>
                        <div class="scene-overlay"></div>
                    </div>
                    <div class="card-body">
                        <div class="card-meta">
                            <span class="card-status ${project.status}">
                                <span class="card-status-dot"></span>
                                ${project.status === 'live' ? 'Live' : 'In Development'}
                            </span>
                            <span class="card-category">${project.category}</span>
                        </div>
                        <h3 class="card-title">${project.title}</h3>
                        <p class="card-description">${project.description}</p>
                        <div class="card-tech">
                            ${project.tech.map(t => `<span class="tech-tag">${t}</span>`).join('')}
                        </div>
                        <div class="card-actions">
                            ${project.url
                                ? `<a href="${project.url}" class="card-launch" target="_blank" rel="noopener">
                                       Launch <span class="card-launch-arrow">→</span>
                                   </a>`
                                : `<span class="card-launch disabled">Coming Soon</span>`
                            }
                        </div>
                    </div>
                `;

                // Setup shader scene
                const canvas = card.querySelector('.card-canvas');
                const scene = new CardScene(canvas, project.id);
                this.scenes.set(project.id, scene);

                // Setup micro-interactions with GSAP
                this.setupCardInteractions(card, scene);

                return card;
            }

            setupCardInteractions(card, scene) {
                let isDragging = false;
                let startX, startY;
                let currentX = 0, currentY = 0;

                // Hover
                card.addEventListener('mouseenter', () => {
                    scene.isHovered = true;
                    gsap.to(card, {
                        y: -8,
                        duration: 0.4,
                        ease: 'power2.out'
                    });
                });

                card.addEventListener('mouseleave', () => {
                    scene.isHovered = false;
                    if (!isDragging) {
                        gsap.to(card, {
                            x: 0,
                            y: 0,
                            rotateX: 0,
                            rotateY: 0,
                            duration: 0.6,
                            ease: 'elastic.out(1, 0.5)'
                        });
                    }
                });

                // Drag micro-interaction (subtle movement)
                card.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.card-launch')) return; // Don't drag on button

                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    card.classList.add('is-dragging');
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    const deltaX = (e.clientX - startX) * 0.15; // Reduced movement
                    const deltaY = (e.clientY - startY) * 0.15;

                    // Clamp movement
                    currentX = Math.max(-20, Math.min(20, deltaX));
                    currentY = Math.max(-20, Math.min(20, deltaY));

                    gsap.to(card, {
                        x: currentX,
                        y: currentY,
                        rotateY: currentX * 0.3,
                        rotateX: -currentY * 0.3,
                        duration: 0.1,
                        ease: 'power1.out'
                    });
                });

                document.addEventListener('mouseup', () => {
                    if (!isDragging) return;
                    isDragging = false;
                    card.classList.remove('is-dragging');

                    // Spring back
                    gsap.to(card, {
                        x: 0,
                        y: 0,
                        rotateX: 0,
                        rotateY: 0,
                        duration: 0.8,
                        ease: 'elastic.out(1, 0.4)'
                    });
                });

                // Mouse follow tilt (subtle 3D effect)
                card.addEventListener('mousemove', (e) => {
                    if (isDragging) return;

                    const rect = card.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / rect.width - 0.5;
                    const y = (e.clientY - rect.top) / rect.height - 0.5;

                    gsap.to(card, {
                        rotateY: x * 8,
                        rotateX: -y * 8,
                        duration: 0.3,
                        ease: 'power1.out'
                    });
                });
            }

            setupFilters() {
                const filterBtns = document.querySelectorAll('.filter-btn');

                filterBtns.forEach(btn => {
                    btn.addEventListener('click', () => {
                        filterBtns.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        this.currentFilter = btn.dataset.filter;
                        this.filterCards();
                    });
                });
            }

            filterCards() {
                const cards = document.querySelectorAll('.project-card');

                cards.forEach(card => {
                    const status = card.dataset.status;
                    const shouldShow = this.currentFilter === 'all' || status === this.currentFilter;

                    gsap.to(card, {
                        opacity: shouldShow ? 1 : 0.3,
                        scale: shouldShow ? 1 : 0.95,
                        duration: 0.3,
                        ease: 'power2.out'
                    });
                });
            }

            setupScrollAnimations() {
                const cards = document.querySelectorAll('.project-card');

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach((entry, i) => {
                        if (entry.isIntersecting) {
                            const delay = parseInt(entry.target.dataset.index) * 0.1;
                            gsap.to(entry.target, {
                                opacity: 1,
                                y: 0,
                                duration: 0.6,
                                delay: delay,
                                ease: 'power2.out',
                                onComplete: () => {
                                    // Resize scene after card is visible
                                    const canvas = entry.target.querySelector('.card-canvas');
                                    if (canvas) {
                                        const scene = this.scenes.get(canvas.dataset.project);
                                        if (scene) scene.resize();
                                    }
                                }
                            });
                            entry.target.classList.add('visible');
                        }
                    });
                }, { threshold: 0.1 });

                cards.forEach(card => observer.observe(card));
            }

            animate() {
                const time = performance.now() * 0.001;

                this.scenes.forEach(scene => {
                    scene.update(time);
                });

                requestAnimationFrame(() => this.animate());
            }
        }

        // Initialize
        let labsApp;
        window.addEventListener('DOMContentLoaded', () => {
            labsApp = new LabsApp();
            window.labsApp = labsApp;

            // Initial resize after layout settles
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    labsApp.scenes.forEach(scene => scene.resize());
                });
            });
        });

        // Handle resize
        window.addEventListener('resize', () => {
            if (labsApp) {
                labsApp.scenes.forEach(scene => scene.resize());
            }
        });
    </script>
</body>
</html>
