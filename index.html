<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraByte Labs | Unified Experiment Hub</title>
    <meta name="description" content="NeuraByte Labs - Interactive experiment hub with unified cards. Each project showcased with its own animated scene.">
    <meta name="robots" content="noindex, nofollow">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ”¬</text></svg>">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           NEURABYTE LABS v6.0 - UNIFIED CARDS
           Each card = Scene + Content in one unified component
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        :root {
            --void: #020617;
            --surface: #111113;
            --surface-elevated: #1a1a1d;
            --spinoza-yellow: #fbbf24;
            --spinoza-yellow-rgb: 251, 191, 36;
            --spinoza-indigo: #6366f1;
            --spinoza-indigo-rgb: 99, 102, 241;
            --neutral-50: #fafafa;
            --neutral-400: #a1a1aa;
            --neutral-500: #71717a;
            --neutral-600: #52525b;
            --success: #22c55e;
            --font-serif: 'Cinzel', Georgia, serif;
            --font-sans: 'Inter', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            scroll-behavior: smooth;
        }

        body {
            min-height: 100vh;
            font-family: var(--font-sans);
            background: var(--void);
            color: var(--neutral-50);
            overflow-x: hidden;
        }

        /* Background Canvas - Subtle neural network */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.4;
        }

        /* Main Container */
        .container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            padding: 24px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(2, 6, 23, 0.95), transparent);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: var(--neutral-50);
        }

        .logo-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, var(--spinoza-yellow), #d97706);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-serif);
            font-weight: 700;
            font-size: 1.3rem;
            color: var(--void);
        }

        .logo-text {
            font-family: var(--font-serif);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .logo-text span { color: var(--spinoza-yellow); }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .version-badge {
            padding: 6px 12px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: 100px;
            font-size: 0.7rem;
            color: var(--spinoza-yellow);
            font-family: var(--font-mono);
        }

        .back-link {
            color: var(--neutral-400);
            text-decoration: none;
            font-size: 0.875rem;
            font-family: var(--font-mono);
            transition: color 0.15s;
        }

        .back-link:hover { color: var(--spinoza-yellow); }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 60px 32px 40px;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: 100px;
            font-size: 0.75rem;
            color: var(--spinoza-yellow);
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 24px;
        }

        .hero-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--spinoza-yellow);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
            box-shadow: 0 0 8px var(--spinoza-yellow);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        h1 {
            font-family: var(--font-serif);
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 700;
            margin-bottom: 16px;
            letter-spacing: 0.02em;
        }

        h1 .highlight {
            color: var(--spinoza-yellow);
            text-shadow: 0 0 40px rgba(251, 191, 36, 0.4);
        }

        .hero-subtitle {
            font-size: 1rem;
            color: var(--neutral-400);
            max-width: 500px;
            margin: 0 auto;
        }

        /* Cards Grid */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 28px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 32px 80px;
        }

        /* Unified Card */
        .unified-card {
            position: relative;
            border-radius: 20px;
            overflow: hidden;
            background: rgba(17, 17, 19, 0.95);
            border: 1px solid rgba(251, 191, 36, 0.12);
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            transform-origin: center center;
        }

        .unified-card:hover {
            transform: translateY(-12px) scale(1.02);
            border-color: rgba(251, 191, 36, 0.5);
            box-shadow:
                0 30px 60px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(251, 191, 36, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .unified-card:active {
            transform: translateY(-8px) scale(1.01);
        }

        /* Card Scene (Shader Canvas) */
        .card-scene {
            width: 100%;
            height: 180px;
            position: relative;
            overflow: hidden;
            background: linear-gradient(180deg, rgba(2, 6, 23, 0.8), rgba(17, 17, 19, 0.9));
        }

        .scene-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .scene-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to top, rgba(17, 17, 19, 1), transparent);
            pointer-events: none;
        }

        /* Card Body */
        .card-body {
            padding: 24px;
            position: relative;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .card-category {
            font-size: 0.65rem;
            color: var(--spinoza-yellow);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-family: var(--font-mono);
        }

        .card-status {
            padding: 4px 10px;
            border-radius: 100px;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-family: var(--font-mono);
        }

        .status-live {
            background: rgba(34, 197, 94, 0.15);
            color: var(--success);
            border: 1px solid rgba(34, 197, 94, 0.25);
        }

        .status-dev {
            background: rgba(99, 102, 241, 0.15);
            color: var(--spinoza-indigo);
            border: 1px solid rgba(99, 102, 241, 0.25);
        }

        .card-title {
            font-family: var(--font-serif);
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 10px;
            transition: color 0.3s;
        }

        .unified-card:hover .card-title {
            color: var(--spinoza-yellow);
        }

        .card-description {
            font-size: 0.85rem;
            color: var(--neutral-400);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tag {
            padding: 4px 10px;
            background: rgba(251, 191, 36, 0.08);
            border-radius: 6px;
            font-size: 0.7rem;
            color: var(--spinoza-yellow);
            font-family: var(--font-mono);
            border: 1px solid rgba(251, 191, 36, 0.1);
            transition: all 0.3s;
        }

        .unified-card:hover .tag {
            background: rgba(251, 191, 36, 0.15);
            border-color: rgba(251, 191, 36, 0.25);
        }

        .card-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--spinoza-yellow);
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
            font-family: var(--font-mono);
            transition: gap 0.3s, color 0.3s;
            position: relative;
            z-index: 10;
        }

        .card-link:hover {
            gap: 14px;
            color: #fde68a;
        }

        .card-link.disabled {
            color: var(--neutral-600);
            cursor: default;
            pointer-events: none;
        }

        .card-link .arrow {
            transition: transform 0.3s;
        }

        .card-link:hover .arrow {
            transform: translateX(4px);
        }

        /* Click Glow Effect */
        .card-glow {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            background: radial-gradient(
                circle at var(--glow-x, 50%) var(--glow-y, 50%),
                rgba(251, 191, 36, 0.5) 0%,
                rgba(251, 191, 36, 0.2) 30%,
                transparent 70%
            );
            z-index: 5;
        }

        .unified-card.clicking .card-glow {
            animation: glowPulse 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes glowPulse {
            0% { opacity: 0; transform: scale(0.8); }
            30% { opacity: 1; }
            100% { opacity: 0; transform: scale(1.3); }
        }

        /* Hover glow border */
        .card-border-glow {
            position: absolute;
            inset: -1px;
            border-radius: 21px;
            background: linear-gradient(
                135deg,
                rgba(251, 191, 36, 0) 0%,
                rgba(251, 191, 36, 0.3) 50%,
                rgba(251, 191, 36, 0) 100%
            );
            opacity: 0;
            transition: opacity 0.5s;
            z-index: -1;
            pointer-events: none;
        }

        .unified-card:hover .card-border-glow {
            opacity: 1;
            animation: borderRotate 3s linear infinite;
        }

        @keyframes borderRotate {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 40px 32px;
            color: var(--neutral-500);
            font-size: 0.85rem;
            border-top: 1px solid rgba(251, 191, 36, 0.1);
            margin-top: auto;
        }

        footer a {
            color: var(--spinoza-yellow);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header {
                padding: 16px 20px;
            }

            .hero {
                padding: 40px 20px 30px;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                padding: 20px 16px 60px;
                gap: 20px;
            }

            .unified-card:hover {
                transform: translateY(-6px) scale(1.01);
            }
        }

        /* Loading State */
        .loading {
            position: fixed;
            inset: 0;
            background: var(--void);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s, visibility 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loading-text {
            font-family: var(--font-mono);
            color: var(--spinoza-yellow);
            font-size: 0.9rem;
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Loading -->
    <div class="loading" id="loading">
        <div class="loading-text">Initializing Labs...</div>
    </div>

    <!-- Background Canvas -->
    <canvas id="bg-canvas"></canvas>

    <!-- Main Container -->
    <div class="container">
        <header>
            <a href="https://neurabytelabs.com" class="logo">
                <div class="logo-icon">N</div>
                <div class="logo-text">Neura<span>Byte</span> Labs</div>
            </a>
            <div class="header-right">
                <span class="version-badge">v6.0</span>
                <a href="https://neurabytelabs.com" class="back-link">â† neurabytelabs.com</a>
            </div>
        </header>

        <section class="hero">
            <div class="hero-badge">Experiment Hub</div>
            <h1>Explore the <span class="highlight">Experiments</span></h1>
            <p class="hero-subtitle">Each card showcases a project with its own interactive scene. Hover to activate, click to launch.</p>
        </section>

        <div class="cards-grid" id="cards-grid">
            <!-- Cards will be generated by JavaScript -->
        </div>

        <footer>
            Part of <a href="https://neurabytelabs.com">NeuraByte Labs</a> Â· Built in Germany Â· 50 Year Vision
        </footer>
    </div>

    <!-- Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const PROJECTS = [
            {
                id: 'spinozaos',
                title: 'SpinozaOS',
                category: 'Design Systems',
                description: 'Award-winning design system for the Age of Superintelligence. "More Geometrico" philosophy.',
                tech: ['Design Tokens', 'React', 'Motion'],
                status: 'live',
                url: 'https://github.com/mrsarac/spinozaos'
            },
            {
                id: 'lithosphere',
                title: 'Lithosphere',
                category: 'Physics & Visualization',
                description: 'N-body gravitational physics simulation with Newton, Artistic, and Magnetic modes.',
                tech: ['Three.js', 'WebGPU', 'Physics'],
                status: 'live',
                url: 'https://lithosphere.mustafasarac.com'
            },
            {
                id: 'boardroom',
                title: 'Cognitive Boardroom',
                category: 'AI Experiments',
                description: 'AI-powered boardroom simulator with 5 personas. System 2 thinking in action.',
                tech: ['Gemini AI', 'React', 'Real-time'],
                status: 'live',
                url: 'https://board.phinote.com'
            },
            {
                id: 'nexus',
                title: 'NEXUS AI Forge',
                category: 'Developer Tools',
                description: 'Ultimate AI-augmented developer tool. Cross-platform, Rust-powered, multi-model AI.',
                tech: ['Rust', 'Multi-AI', 'CLI'],
                status: 'live',
                url: 'https://github.com/mrsarac/NEXUS-AI-Forge'
            },
            {
                id: 'oracle',
                title: 'ORACLE Engine',
                category: 'AI Simulation',
                description: 'Strategic decision simulation platform. Gemini AI-powered scenario analysis.',
                tech: ['Gemini AI', 'Python', 'Strategy'],
                status: 'live',
                url: 'https://github.com/mrsarac/ORACLE-Engine'
            },
            {
                id: 'engram',
                title: 'Engram Memory',
                category: 'Learning & Memory',
                description: 'Cyberpunk memory prosthetic. AI-powered flashcards with FSRS spaced repetition.',
                tech: ['FSRS', 'AI', 'Cyberpunk'],
                status: 'dev',
                url: null
            },
            {
                id: 'manifesto',
                title: 'Digital Renaissance',
                category: 'Philosophy & Education',
                description: 'Manifesto for the Age of Autodidacts. AI-powered self-learning revolution.',
                tech: ['AI Education', 'Philosophy', 'Manifesto'],
                status: 'live',
                url: 'https://readwise.io/reader/shared/01kayk0tzxvfc603qbvmcwfr21/'
            },
            {
                id: 'voice',
                title: 'NeuraByte Voice',
                category: 'Native Apps',
                description: 'Zero-latency voice-to-text for macOS & iOS. Push-to-talk with premium animations.',
                tech: ['Swift', 'macOS', 'iOS'],
                status: 'dev',
                url: null
            }
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SHADER CODE - Per-Project Scenes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const VERTEX_SHADER = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const FRAGMENT_SHADERS = {
            // SpinozaOS - Sacred Geometry
            spinozaos: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                uniform vec2 uResolution;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec2 center = uv - 0.5;
                    float dist = length(center);
                    float angle = atan(center.y, center.x);

                    // Sacred geometry - rotating hexagon
                    float speed = 0.3 + uHover * 0.7;
                    float rotation = uTime * speed;

                    // Golden ratio spiral
                    float phi = 1.618033988749;
                    float spiral = sin(dist * 20.0 - uTime * 2.0 * speed) * 0.5 + 0.5;

                    // Hexagon pattern
                    float segments = 6.0;
                    float hex = cos(angle * segments + rotation) * 0.5 + 0.5;

                    // Combine effects
                    float pattern = spiral * 0.5 + hex * 0.5;
                    pattern *= smoothstep(0.5, 0.1, dist);

                    // Colors - golden geometry
                    vec3 color = vec3(0.0);
                    color += vec3(0.98, 0.75, 0.14) * pattern * (0.3 + uHover * 0.7);
                    color += vec3(0.4, 0.4, 0.95) * (1.0 - pattern) * 0.1;

                    // Click pulse
                    color += vec3(1.0, 0.9, 0.5) * uClick * exp(-dist * 3.0);

                    // Vignette
                    color *= 1.0 - dist * 0.5;

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // Lithosphere - Orbiting Bodies
            lithosphere: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec2 center = uv - 0.5;
                    float dist = length(center);

                    vec3 color = vec3(0.0);
                    float speed = 0.5 + uHover * 1.5;

                    // Central body
                    float sun = smoothstep(0.08, 0.05, dist);
                    color += vec3(1.0, 0.8, 0.3) * sun;

                    // Orbiting bodies
                    for (float i = 0.0; i < 3.0; i++) {
                        float orbitRadius = 0.15 + i * 0.1;
                        float orbitSpeed = (1.0 - i * 0.2) * speed;
                        float phase = i * 2.094;

                        vec2 bodyPos = vec2(
                            cos(uTime * orbitSpeed + phase) * orbitRadius,
                            sin(uTime * orbitSpeed + phase) * orbitRadius * 0.6
                        );

                        float bodyDist = length(center - bodyPos);
                        float body = smoothstep(0.04, 0.02, bodyDist);

                        vec3 bodyColor = vec3(0.3 + i * 0.2, 0.5, 0.8 - i * 0.2);
                        color += bodyColor * body;

                        // Orbit trail
                        float trail = smoothstep(orbitRadius + 0.01, orbitRadius - 0.01, dist);
                        trail *= smoothstep(orbitRadius - 0.01, orbitRadius + 0.01, dist);
                        color += bodyColor * trail * 0.15 * (0.3 + uHover * 0.7);
                    }

                    // Click pulse
                    color += vec3(0.5, 0.7, 1.0) * uClick * exp(-dist * 4.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // Boardroom - Neural Network
            boardroom: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;
                    vec3 color = vec3(0.02, 0.02, 0.05);

                    float speed = 0.5 + uHover * 1.0;

                    // Neural nodes
                    for (float i = 0.0; i < 8.0; i++) {
                        vec2 nodePos = vec2(
                            0.15 + random(vec2(i, 0.0)) * 0.7,
                            0.15 + random(vec2(0.0, i)) * 0.7
                        );

                        // Pulse animation
                        float pulse = sin(uTime * speed * 3.0 + i * 1.5) * 0.5 + 0.5;
                        float activity = 0.3 + uHover * 0.7;

                        float nodeDist = length(uv - nodePos);
                        float node = smoothstep(0.04, 0.02, nodeDist) * pulse * activity;

                        color += vec3(0.4, 0.8, 1.0) * node;

                        // Synaptic glow
                        float glow = exp(-nodeDist * 15.0) * pulse * activity * 0.3;
                        color += vec3(0.2, 0.5, 0.8) * glow;
                    }

                    // Connection lines (simplified)
                    float lines = 0.0;
                    for (float i = 0.0; i < 4.0; i++) {
                        vec2 start = vec2(0.2 + i * 0.15, 0.3);
                        vec2 end = vec2(0.3 + i * 0.12, 0.7);
                        vec2 dir = normalize(end - start);
                        vec2 toPoint = uv - start;
                        float proj = clamp(dot(toPoint, dir), 0.0, length(end - start));
                        vec2 closest = start + dir * proj;
                        float lineDist = length(uv - closest);
                        float pulse = sin(uTime * speed * 2.0 - proj * 5.0) * 0.5 + 0.5;
                        lines += smoothstep(0.008, 0.002, lineDist) * pulse * (0.2 + uHover * 0.5);
                    }
                    color += vec3(0.3, 0.6, 0.9) * lines;

                    // Click pulse
                    float clickDist = length(uv - 0.5);
                    color += vec3(0.5, 0.8, 1.0) * uClick * exp(-clickDist * 4.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // NEXUS - Matrix Code Rain
            nexus: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                void main() {
                    vec2 uv = vUv;
                    vec3 color = vec3(0.0, 0.02, 0.0);

                    float speed = 0.3 + uHover * 1.2;

                    // Matrix rain columns
                    for (float i = 0.0; i < 12.0; i++) {
                        float colX = (i + 0.5) / 12.0;
                        float offset = random(vec2(i, 0.0)) * 10.0;
                        float fallSpeed = 0.5 + random(vec2(i, 1.0)) * 0.5;

                        // Falling character position
                        float charY = fract(uTime * speed * fallSpeed + offset);

                        // Distance to character
                        vec2 charPos = vec2(colX, 1.0 - charY);
                        float charDist = length(uv - charPos);

                        // Character glow
                        float charGlow = smoothstep(0.05, 0.01, charDist);
                        color += vec3(0.1, 1.0, 0.3) * charGlow * 0.8;

                        // Trail behind character
                        float trail = smoothstep(0.0, 0.3, charY - (1.0 - uv.y));
                        trail *= smoothstep(0.03, 0.01, abs(uv.x - colX));
                        color += vec3(0.0, 0.5, 0.15) * trail * 0.3 * (0.3 + uHover * 0.7);
                    }

                    // Rust orange accent (NEXUS branding)
                    float centerGlow = exp(-length(uv - 0.5) * 3.0);
                    float pulse = sin(uTime * 2.0) * 0.3 + 0.5;
                    color += vec3(0.9, 0.4, 0.1) * centerGlow * pulse * 0.3 * (0.5 + uHover * 0.5);

                    // Click burst
                    color += vec3(0.2, 1.0, 0.4) * uClick * exp(-length(uv - 0.5) * 3.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // ORACLE - Decision Tree
            oracle: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec3 color = vec3(0.02, 0.01, 0.04);

                    float speed = 0.5 + uHover * 1.0;

                    // Central oracle eye
                    vec2 center = uv - vec2(0.5, 0.6);
                    float eyeDist = length(center);
                    float eyeRadius = 0.08 + sin(uTime * speed) * 0.01;
                    float eye = smoothstep(eyeRadius + 0.02, eyeRadius, eyeDist);
                    color += vec3(0.6, 0.3, 0.9) * eye;

                    // Pupil
                    float pupil = smoothstep(0.03, 0.02, eyeDist);
                    color = mix(color, vec3(0.1, 0.05, 0.2), pupil);

                    // Decision branches
                    for (float i = 0.0; i < 6.0; i++) {
                        float angle = i * 1.047 + uTime * speed * 0.2;
                        vec2 branchDir = vec2(cos(angle), sin(angle));
                        vec2 branchStart = vec2(0.5, 0.6) + branchDir * 0.12;
                        vec2 branchEnd = branchStart + branchDir * 0.25;

                        // Line distance
                        vec2 toPoint = uv - branchStart;
                        vec2 dir = normalize(branchEnd - branchStart);
                        float proj = clamp(dot(toPoint, dir), 0.0, length(branchEnd - branchStart));
                        vec2 closest = branchStart + dir * proj;
                        float lineDist = length(uv - closest);

                        float branch = smoothstep(0.01, 0.003, lineDist);
                        float activity = sin(uTime * speed * 2.0 + i) * 0.5 + 0.5;
                        color += vec3(0.5, 0.2, 0.8) * branch * activity * (0.3 + uHover * 0.7);

                        // Decision node at end
                        float nodeDist = length(uv - branchEnd);
                        float node = smoothstep(0.025, 0.015, nodeDist) * activity;
                        color += vec3(0.8, 0.4, 1.0) * node * (0.5 + uHover * 0.5);
                    }

                    // Click divination burst
                    color += vec3(0.7, 0.4, 1.0) * uClick * exp(-eyeDist * 5.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // Engram - Memory Cubes
            engram: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec3 color = vec3(0.02, 0.02, 0.05);

                    float speed = 0.3 + uHover * 0.8;

                    // Memory cube grid
                    vec2 gridUv = fract(uv * 3.0);
                    vec2 gridId = floor(uv * 3.0);

                    // Cube effect
                    float cubePhase = gridId.x + gridId.y * 3.0;
                    float rotation = uTime * speed + cubePhase * 0.5;

                    // Pseudo 3D cube face
                    vec2 cubeCenter = gridUv - 0.5;
                    float cubeDist = max(abs(cubeCenter.x), abs(cubeCenter.y));
                    float cube = smoothstep(0.4, 0.35, cubeDist);

                    // Memory pulse
                    float pulse = sin(uTime * speed * 2.0 + cubePhase) * 0.5 + 0.5;
                    float activity = 0.3 + uHover * 0.7;

                    // Cyberpunk colors - cyan/magenta
                    vec3 cubeColor = mix(
                        vec3(0.0, 0.8, 0.9),
                        vec3(0.9, 0.2, 0.8),
                        sin(cubePhase * 0.7) * 0.5 + 0.5
                    );

                    color += cubeColor * cube * pulse * activity;

                    // Data streams
                    float stream = sin(uv.y * 30.0 - uTime * speed * 3.0) * 0.5 + 0.5;
                    stream *= smoothstep(0.3, 0.0, abs(fract(uv.x * 6.0) - 0.5));
                    color += vec3(0.0, 0.5, 0.5) * stream * 0.1 * (0.5 + uHover * 0.5);

                    // Click pulse
                    float clickDist = length(uv - 0.5);
                    color += vec3(0.0, 1.0, 0.9) * uClick * exp(-clickDist * 4.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // Manifesto - Knowledge Waves
            manifesto: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec3 color = vec3(0.03, 0.02, 0.01);

                    float speed = 0.3 + uHover * 0.7;

                    // Open book shape
                    float bookSpine = smoothstep(0.02, 0.005, abs(uv.x - 0.5));
                    color += vec3(0.6, 0.5, 0.3) * bookSpine * 0.5;

                    // Page glow
                    float leftPage = smoothstep(0.5, 0.15, uv.x) * smoothstep(0.1, 0.2, uv.y) * smoothstep(0.9, 0.8, uv.y);
                    float rightPage = smoothstep(0.5, 0.85, uv.x) * smoothstep(0.1, 0.2, uv.y) * smoothstep(0.9, 0.8, uv.y);
                    color += vec3(0.95, 0.9, 0.8) * (leftPage + rightPage) * 0.15;

                    // Text lines (abstract)
                    for (float i = 0.0; i < 6.0; i++) {
                        float lineY = 0.25 + i * 0.1;
                        float lineWidth = 0.15 + sin(i * 2.0 + uTime * speed) * 0.05;

                        // Left page lines
                        float leftLine = smoothstep(0.005, 0.002, abs(uv.y - lineY));
                        leftLine *= smoothstep(0.15, 0.18, uv.x) * smoothstep(0.45, 0.42, uv.x);
                        leftLine *= step(0.0, sin(uv.x * 50.0 + i * 10.0)); // Dashed effect

                        // Right page lines
                        float rightLine = smoothstep(0.005, 0.002, abs(uv.y - lineY));
                        rightLine *= smoothstep(0.55, 0.58, uv.x) * smoothstep(0.85, 0.82, uv.x);
                        rightLine *= step(0.0, sin(uv.x * 50.0 + i * 10.0 + 3.14));

                        float activity = 0.3 + uHover * 0.7;
                        color += vec3(0.3, 0.25, 0.2) * (leftLine + rightLine) * activity;
                    }

                    // Knowledge emanation
                    for (float i = 0.0; i < 5.0; i++) {
                        float angle = (i / 5.0) * 3.14159 - 1.57;
                        vec2 rayDir = vec2(cos(angle), sin(angle));
                        vec2 rayStart = vec2(0.5, 0.5);

                        float rayDist = dot(uv - rayStart, rayDir);
                        float rayPerp = length(uv - rayStart - rayDir * rayDist);

                        float ray = smoothstep(0.03, 0.01, rayPerp) * smoothstep(0.0, 0.1, rayDist) * smoothstep(0.4, 0.2, rayDist);
                        float pulse = sin(uTime * speed * 2.0 - rayDist * 5.0 + i) * 0.5 + 0.5;
                        color += vec3(1.0, 0.85, 0.5) * ray * pulse * 0.3 * (0.3 + uHover * 0.7);
                    }

                    // Click enlightenment
                    float clickDist = length(uv - vec2(0.5, 0.5));
                    color += vec3(1.0, 0.95, 0.7) * uClick * exp(-clickDist * 4.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // Voice - Audio Waveform
            voice: `
                uniform float uTime;
                uniform float uHover;
                uniform float uClick;
                varying vec2 vUv;

                void main() {
                    vec2 uv = vUv;
                    vec3 color = vec3(0.02, 0.02, 0.03);

                    float speed = 0.5 + uHover * 1.0;

                    // Microphone icon (simplified)
                    vec2 micCenter = vec2(0.5, 0.55);
                    float micBody = smoothstep(0.08, 0.06, length((uv - micCenter) * vec2(1.0, 0.7)));
                    float micTop = smoothstep(0.06, 0.04, length(uv - vec2(0.5, 0.65)));
                    color += vec3(0.4, 0.4, 0.5) * max(micBody, micTop) * 0.5;

                    // Audio waveform rings
                    for (float i = 1.0; i <= 4.0; i++) {
                        float radius = 0.1 + i * 0.08;
                        float ringDist = abs(length(uv - micCenter) - radius);
                        float ring = smoothstep(0.015, 0.005, ringDist);

                        float wave = sin(uTime * speed * 3.0 - i * 1.5) * 0.5 + 0.5;
                        float activity = 0.2 + uHover * 0.8;

                        vec3 ringColor = mix(vec3(0.3, 0.5, 0.9), vec3(0.9, 0.5, 0.3), i / 4.0);
                        color += ringColor * ring * wave * activity;
                    }

                    // Spectrum bars at bottom
                    float barY = 0.15;
                    for (float i = 0.0; i < 7.0; i++) {
                        float barX = 0.25 + i * 0.08;
                        float barHeight = 0.05 + sin(uTime * speed * 4.0 + i * 0.8) * 0.04 * (0.3 + uHover * 0.7);

                        float bar = step(barX - 0.015, uv.x) * step(uv.x, barX + 0.015);
                        bar *= step(barY - barHeight, uv.y) * step(uv.y, barY + barHeight);

                        vec3 barColor = mix(vec3(0.2, 0.6, 1.0), vec3(1.0, 0.4, 0.6), i / 7.0);
                        color += barColor * bar * 0.8;
                    }

                    // Click sound burst
                    float clickDist = length(uv - micCenter);
                    color += vec3(0.5, 0.7, 1.0) * uClick * exp(-clickDist * 4.0);

                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CARD SHADER SCENE CLASS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class CardShaderScene {
            constructor(canvas, projectId) {
                this.canvas = canvas;
                this.projectId = projectId;
                this.isHovered = false;
                this.hoverIntensity = 0;
                this.clickPulse = 0;

                this.init();
            }

            init() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: false,
                    powerPreference: 'low-power'
                });

                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                const fragmentShader = FRAGMENT_SHADERS[this.projectId] || FRAGMENT_SHADERS.spinozaos;

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uHover: { value: 0 },
                        uClick: { value: 0 },
                        uResolution: { value: new THREE.Vector2() }
                    },
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: fragmentShader
                });

                const geometry = new THREE.PlaneGeometry(2, 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.scene.add(this.mesh);

                this.resize();
            }

            setHovered(value) {
                this.isHovered = value;
            }

            triggerClick() {
                this.clickPulse = 1.0;
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio, 2);
                this.renderer.setSize(rect.width * dpr, rect.height * dpr, false);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.material.uniforms.uResolution.value.set(rect.width, rect.height);
            }

            update(time) {
                // Smooth hover transition
                const targetHover = this.isHovered ? 1.0 : 0.0;
                this.hoverIntensity += (targetHover - this.hoverIntensity) * 0.08;

                // Click pulse decay
                this.clickPulse *= 0.9;

                this.material.uniforms.uTime.value = time;
                this.material.uniforms.uHover.value = this.hoverIntensity;
                this.material.uniforms.uClick.value = this.clickPulse;

                this.renderer.render(this.scene, this.camera);
            }

            dispose() {
                this.material.dispose();
                this.mesh.geometry.dispose();
                this.renderer.dispose();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BACKGROUND SHADER (Simplified Neural Network)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class BackgroundScene {
            constructor(canvas) {
                this.canvas = canvas;
                this.init();
            }

            init() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: false
                });

                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uResolution: { value: new THREE.Vector2() }
                    },
                    vertexShader: VERTEX_SHADER,
                    fragmentShader: `
                        uniform float uTime;
                        uniform vec2 uResolution;
                        varying vec2 vUv;

                        float random(vec2 st) {
                            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                        }

                        void main() {
                            vec2 uv = vUv;
                            vec3 color = vec3(0.008, 0.02, 0.055);

                            // Subtle floating particles
                            for (float i = 0.0; i < 20.0; i++) {
                                vec2 pos = vec2(
                                    random(vec2(i, 0.0)),
                                    fract(random(vec2(0.0, i)) + uTime * 0.02 * (0.5 + random(vec2(i, i)) * 0.5))
                                );

                                float dist = length(uv - pos);
                                float particle = smoothstep(0.02, 0.005, dist);
                                float twinkle = sin(uTime * 2.0 + i * 1.5) * 0.5 + 0.5;

                                color += vec3(0.98, 0.75, 0.14) * particle * twinkle * 0.3;
                            }

                            // Subtle grid
                            vec2 grid = abs(fract(uv * 20.0) - 0.5);
                            float gridLine = smoothstep(0.48, 0.5, max(grid.x, grid.y));
                            color += vec3(0.98, 0.75, 0.14) * gridLine * 0.02;

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });

                const geometry = new THREE.PlaneGeometry(2, 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.scene.add(this.mesh);

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            }

            update(time) {
                this.material.uniforms.uTime.value = time;
                this.renderer.render(this.scene, this.camera);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UNIFIED CARDS MANAGER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class UnifiedCardsManager {
            constructor() {
                this.scenes = new Map();
                this.backgroundScene = null;
                this.init();
            }

            init() {
                // Create background
                const bgCanvas = document.getElementById('bg-canvas');
                this.backgroundScene = new BackgroundScene(bgCanvas);

                // Generate cards
                this.generateCards();

                // Setup card interactions
                this.setupInteractions();

                // Start animation loop
                this.animate();

                // Hide loading
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 500);
            }

            generateCards() {
                const grid = document.getElementById('cards-grid');

                PROJECTS.forEach(project => {
                    const card = document.createElement('article');
                    card.className = 'unified-card';
                    card.dataset.project = project.id;
                    card.dataset.url = project.url || '';

                    card.innerHTML = `
                        <div class="card-border-glow"></div>
                        <div class="card-scene">
                            <canvas class="scene-canvas"></canvas>
                            <div class="scene-overlay"></div>
                        </div>
                        <div class="card-body">
                            <div class="card-header">
                                <span class="card-category">${project.category}</span>
                                <span class="card-status ${project.status === 'live' ? 'status-live' : 'status-dev'}">
                                    ${project.status === 'live' ? 'Live' : 'In Dev'}
                                </span>
                            </div>
                            <h3 class="card-title">${project.title}</h3>
                            <p class="card-description">${project.description}</p>
                            <div class="card-tags">
                                ${project.tech.map(t => `<span class="tag">${t}</span>`).join('')}
                            </div>
                            ${project.url
                                ? `<a href="${project.url}" class="card-link" target="_blank" rel="noopener">
                                    Launch <span class="arrow">â†’</span>
                                   </a>`
                                : `<span class="card-link disabled">Coming Soon</span>`
                            }
                        </div>
                        <div class="card-glow"></div>
                    `;

                    grid.appendChild(card);

                    // Create shader scene for this card
                    const canvas = card.querySelector('.scene-canvas');
                    const scene = new CardShaderScene(canvas, project.id);
                    this.scenes.set(card, scene);
                });
            }

            setupInteractions() {
                document.querySelectorAll('.unified-card').forEach(card => {
                    const scene = this.scenes.get(card);
                    const url = card.dataset.url;

                    // Hover events
                    card.addEventListener('mouseenter', () => {
                        scene.setHovered(true);
                    });

                    card.addEventListener('mouseleave', () => {
                        scene.setHovered(false);
                    });

                    // Click with glow effect
                    card.addEventListener('click', (e) => {
                        // If clicking on the link, let it handle navigation
                        if (e.target.closest('.card-link') && url) {
                            return; // Link will handle its own click
                        }

                        // Prevent navigation for disabled links
                        if (e.target.closest('.card-link.disabled')) {
                            e.preventDefault();
                            return;
                        }

                        // Trigger visual effects
                        scene.triggerClick();
                        card.classList.add('clicking');

                        // Update glow position based on click location
                        const rect = card.getBoundingClientRect();
                        const x = ((e.clientX - rect.left) / rect.width) * 100;
                        const y = ((e.clientY - rect.top) / rect.height) * 100;
                        card.style.setProperty('--glow-x', `${x}%`);
                        card.style.setProperty('--glow-y', `${y}%`);

                        // Navigate after animation (if not clicking on link which handles itself)
                        if (url && !e.target.closest('.card-link')) {
                            setTimeout(() => {
                                card.classList.remove('clicking');
                                window.open(url, '_blank');
                            }, 350);
                        } else {
                            setTimeout(() => {
                                card.classList.remove('clicking');
                            }, 600);
                        }
                    });
                });

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.scenes.forEach(scene => scene.resize());
                });
            }

            animate() {
                const time = performance.now() * 0.001;

                // Update background
                this.backgroundScene.update(time);

                // Update all card scenes
                this.scenes.forEach(scene => {
                    scene.update(time);
                });

                requestAnimationFrame(() => this.animate());
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        new UnifiedCardsManager();

    </script>
</body>
</html>
