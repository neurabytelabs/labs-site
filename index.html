<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraByte Labs | Cyber-Kinetic Experiment Hub</title>
    <meta name="description" content="NeuraByte Labs - Interactive 3D experiment hub. Physics simulations, AI demos, and manipulable experiences.">
    <meta name="robots" content="noindex, nofollow">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ”¬</text></svg>">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           NEURABYTE LABS - CYBER-KINETIC EXPERIENCE v3.0
           Three.js + WebGL + Physics-based Interaction
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        :root {
            --void: #020617;
            --surface: #111113;
            --surface-elevated: #1a1a1d;
            --spinoza-yellow: #fbbf24;
            --spinoza-yellow-rgb: 251, 191, 36;
            --spinoza-indigo: #6366f1;
            --spinoza-indigo-rgb: 99, 102, 241;
            --neutral-50: #fafafa;
            --neutral-400: #a1a1aa;
            --neutral-500: #71717a;
            --neutral-600: #52525b;
            --success: #22c55e;
            --font-serif: 'Cinzel', Georgia, serif;
            --font-sans: 'Inter', system-ui, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: var(--font-sans);
            background: var(--void);
            color: var(--neutral-50);
        }

        /* WebGL Canvas */
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        /* UI Overlay */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        #ui-overlay > * {
            pointer-events: auto;
        }

        /* Header */
        header {
            padding: 24px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(2, 6, 23, 0.9), transparent);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: var(--neutral-50);
        }

        .logo-icon {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, var(--spinoza-yellow), #d97706);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: var(--font-serif);
            font-weight: 700;
            font-size: 1.3rem;
            color: var(--void);
        }

        .logo-text {
            font-family: var(--font-serif);
            font-weight: 600;
            font-size: 1.1rem;
        }

        .logo-text span { color: var(--spinoza-yellow); }

        .back-link {
            color: var(--neutral-400);
            text-decoration: none;
            font-size: 0.875rem;
            font-family: var(--font-mono);
            transition: color 0.15s;
        }

        .back-link:hover { color: var(--spinoza-yellow); }

        /* Center Content */
        .center-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 32px;
            pointer-events: none;
        }

        .hero-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.2);
            border-radius: 100px;
            font-size: 0.75rem;
            color: var(--spinoza-yellow);
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 24px;
        }

        .hero-badge::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--spinoza-yellow);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
            box-shadow: 0 0 8px var(--spinoza-yellow);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        h1 {
            font-family: var(--font-serif);
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 700;
            margin-bottom: 16px;
            letter-spacing: 0.02em;
        }

        h1 .highlight {
            color: var(--spinoza-yellow);
            text-shadow: 0 0 40px rgba(251, 191, 36, 0.4);
        }

        .subtitle {
            font-size: 1rem;
            color: var(--neutral-400);
            max-width: 500px;
            line-height: 1.6;
            margin-bottom: 32px;
        }

        .drag-hint {
            font-size: 0.75rem;
            color: var(--neutral-500);
            font-family: var(--font-mono);
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            animation: fadeIn 1s ease-out 2s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Footer */
        footer {
            padding: 24px 32px;
            text-align: center;
            background: linear-gradient(to top, rgba(2, 6, 23, 0.9), transparent);
        }

        .footer-text {
            font-size: 0.75rem;
            color: var(--neutral-500);
        }

        .footer-text a {
            color: var(--neutral-400);
            text-decoration: none;
        }

        .footer-text a:hover { color: var(--spinoza-yellow); }

        /* Card Labels (CSS3D alternative - HTML overlay) */
        .card-labels {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .card-label {
            position: absolute;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease;
            transform-origin: center center;
            will-change: transform, left, top;
        }

        .card-label:hover .card-label-inner {
            transform: scale(1.02);
        }

        .card-label-inner {
            background: rgba(17, 17, 19, 0.85);
            backdrop-filter: blur(12px);
            transition: transform 0.2s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(251, 191, 36, 0.15);
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
            transition: all 0.3s ease;
        }

        .card-label:hover .card-label-inner {
            border-color: rgba(251, 191, 36, 0.4);
            box-shadow:
                0 0 30px rgba(251, 191, 36, 0.1),
                inset 0 0 20px rgba(251, 191, 36, 0.03);
        }

        .card-category {
            font-size: 0.65rem;
            color: var(--spinoza-yellow);
            text-transform: uppercase;
            letter-spacing: 0.12em;
            font-family: var(--font-mono);
            margin-bottom: 8px;
        }

        .card-title {
            font-family: var(--font-serif);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .card-description {
            font-size: 0.8rem;
            color: var(--neutral-400);
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .card-tech {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 12px;
        }

        .tech-tag {
            padding: 3px 8px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
            font-size: 0.65rem;
            color: var(--spinoza-yellow);
            font-family: var(--font-mono);
            border: 1px solid rgba(251, 191, 36, 0.1);
        }

        .card-status {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 4px 10px;
            border-radius: 100px;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-family: var(--font-mono);
        }

        .status-live {
            background: rgba(34, 197, 94, 0.1);
            color: var(--success);
            border: 1px solid rgba(34, 197, 94, 0.2);
        }

        .status-coming {
            background: rgba(113, 113, 122, 0.1);
            color: var(--neutral-500);
            border: 1px solid rgba(113, 113, 122, 0.2);
        }

        .card-link {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: var(--spinoza-yellow);
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 500;
            font-family: var(--font-mono);
            transition: gap 0.2s;
        }

        .card-link:hover { gap: 10px; }

        .card-link-disabled {
            color: var(--neutral-600);
            cursor: not-allowed;
        }

        /* Loading */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(251, 191, 36, 0.1);
            border-top-color: var(--spinoza-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--neutral-500);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--void); }
        ::-webkit-scrollbar-thumb { background: #1e293b; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--spinoza-yellow); }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div class="loading-text">Initializing WebGL...</div>
    </div>

    <!-- WebGL Canvas -->
    <canvas id="webgl-canvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-overlay">
        <header>
            <a href="https://neurabytelabs.com" class="logo">
                <div class="logo-icon">N</div>
                <div class="logo-text">NeuraByte <span>Labs</span></div>
            </a>
            <a href="https://neurabytelabs.com" class="back-link">&larr; neurabytelabs.com</a>
        </header>

        <div class="center-content">
            <div class="hero-badge">Cyber-Kinetic Hub</div>
            <h1>Manipulate the <span class="highlight">Experiments</span></h1>
            <p class="subtitle">Drag, throw, and interact with our experimental projects. Each card is a portal to innovation.</p>
            <div class="drag-hint">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3M2 12h20M12 2v20"/>
                </svg>
                Drag cards to interact
            </div>
        </div>

        <footer>
            <p class="footer-text">
                Part of <a href="https://neurabytelabs.com">NeuraByte Labs</a> &middot;
                Built in Germany &middot; 50 Year Vision
            </p>
        </footer>
    </div>

    <!-- Card Labels Container -->
    <div class="card-labels" id="card-labels"></div>

    <!-- Three.js + Dependencies -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const CONFIG = {
            colors: {
                void: new THREE.Color(0x020617),
                brand: new THREE.Color(0xfbbf24),
                accent: new THREE.Color(0x6366f1),
                surface: new THREE.Color(0x111113)
            },
            grid: {
                count: 40,
                spacing: 2.5,
                depth: -50
            },
            cards: [
                {
                    id: 'lithosphere',
                    title: 'Lithosphere',
                    category: 'Physics & Visualization',
                    description: 'N-body gravitational physics simulation with Newton, Artistic, and Magnetic modes.',
                    tech: ['Three.js', 'WebGPU', 'Physics'],
                    status: 'live',
                    url: 'https://lithosphere.mustafasarac.com',
                    icon: 'ðŸŒŒ'
                },
                {
                    id: 'boardroom',
                    title: 'Cognitive Boardroom',
                    category: 'AI Experiments',
                    description: 'AI-powered boardroom simulator with 5 personas. System 2 thinking in action.',
                    tech: ['Gemini AI', 'React', 'Real-time'],
                    status: 'live',
                    url: 'https://board.phinote.com',
                    icon: 'ðŸ§ '
                },
                {
                    id: 'emotion',
                    title: 'Emotion Lab',
                    category: 'AI Experiments',
                    description: 'Interactive Spinoza emotion analysis. Explore the geometry of affects.',
                    tech: ['CONATUS', 'D3.js', 'Spinoza'],
                    status: 'coming',
                    url: null,
                    icon: 'ðŸ’«'
                },
                {
                    id: 'particle',
                    title: 'Particle Lab',
                    category: 'Physics & Visualization',
                    description: 'WebGPU-powered particle systems. Millions of particles, infinite possibilities.',
                    tech: ['WebGPU', 'Compute', 'GLSL'],
                    status: 'coming',
                    url: null,
                    icon: 'âœ¨'
                }
            ],
            physics: {
                damping: 0.97,
                restitution: 0.6,
                attraction: 0.001,
                throwMultiplier: 8
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SHADER CODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const gridVertexShader = `
            attribute vec3 aOffset;
            attribute float aRandom;

            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uMouseRadius;

            varying float vAlpha;
            varying float vElevation;

            void main() {
                vec3 pos = position + aOffset;

                // Mouse repulsion
                vec2 mouseWorld = (uMouse - 0.5) * 100.0;
                vec2 diff = pos.xy - mouseWorld;
                float dist = length(diff);
                float repulsion = smoothstep(uMouseRadius, 0.0, dist);

                // Push away from mouse
                pos.z += repulsion * 15.0;
                pos.xy += normalize(diff + 0.001) * repulsion * 5.0;

                // Organic wave
                float wave = sin(uTime * 0.5 + aRandom * 6.28 + pos.x * 0.1) *
                             cos(uTime * 0.3 + pos.y * 0.1);
                pos.z += wave * 2.0;

                vElevation = pos.z + 50.0;
                vAlpha = 0.15 + repulsion * 0.6;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const gridFragmentShader = `
            uniform vec3 uColor;
            uniform vec3 uAccentColor;
            uniform float uTime;

            varying float vAlpha;
            varying float vElevation;

            void main() {
                float colorMix = sin(uTime * 0.2 + vElevation * 0.02) * 0.5 + 0.5;
                vec3 color = mix(uColor, uAccentColor, colorMix * 0.3);

                gl_FragColor = vec4(color, vAlpha * 0.4);
            }
        `;

        const cardVertexShader = `
            uniform float uTime;
            uniform float uHover;
            uniform vec2 uMouse;

            varying vec2 vUv;
            varying float vElevation;
            varying vec3 vNormal;
            varying vec3 vPosition;

            void main() {
                vUv = uv;
                vNormal = normal;

                vec3 pos = position;

                // Wave displacement on hover
                float wave = sin(pos.x * 4.0 + uTime * 2.0) * cos(pos.y * 4.0 + uTime * 2.0);
                pos.z += wave * uHover * 3.0;

                // Mouse influence
                vec2 mouseLocal = uMouse * 2.0 - 1.0;
                float mouseDist = length(vUv - uMouse);
                pos.z += (1.0 - mouseDist) * uHover * 5.0;

                vElevation = pos.z;
                vPosition = pos;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const cardFragmentShader = `
            uniform vec3 uColor;
            uniform vec3 uAccentColor;
            uniform float uTime;
            uniform float uHover;
            uniform float uSelected;

            varying vec2 vUv;
            varying float vElevation;
            varying vec3 vNormal;
            varying vec3 vPosition;

            void main() {
                // Base color
                vec3 baseColor = vec3(0.067, 0.067, 0.075);

                // Edge glow (fresnel-like)
                float edgeX = smoothstep(0.0, 0.1, vUv.x) * smoothstep(1.0, 0.9, vUv.x);
                float edgeY = smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.9, vUv.y);
                float edge = 1.0 - (edgeX * edgeY);

                // Animated gradient
                float gradient = sin(vUv.x * 3.14159 + uTime) * 0.5 + 0.5;
                vec3 glowColor = mix(uColor, uAccentColor, gradient);

                // Combine
                vec3 finalColor = baseColor;
                finalColor += edge * glowColor * (0.3 + uHover * 0.5);
                finalColor += vElevation * 0.02 * uColor;

                // Selection highlight
                finalColor += uSelected * glowColor * 0.2;

                float alpha = 0.85 + uHover * 0.1;

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PARTICLE SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        class ParticleEmitter {
            constructor(scene, color) {
                this.particles = [];
                this.scene = scene;
                this.color = color;
                this.maxParticles = 200;

                // Geometry
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.maxParticles * 3);
                const alphas = new Float32Array(this.maxParticles);

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

                // Material
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uColor: { value: color },
                        uTime: { value: 0 }
                    },
                    vertexShader: `
                        attribute float alpha;
                        varying float vAlpha;
                        void main() {
                            vAlpha = alpha;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = 3.0 * (1.0 / -mvPosition.z) * 50.0;
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 uColor;
                        varying float vAlpha;
                        void main() {
                            float dist = length(gl_PointCoord - 0.5);
                            if (dist > 0.5) discard;
                            float alpha = smoothstep(0.5, 0.0, dist) * vAlpha;
                            gl_FragColor = vec4(uColor, alpha);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.mesh = new THREE.Points(geometry, material);
                scene.add(this.mesh);
            }

            emit(position, count = 10) {
                for (let i = 0; i < count; i++) {
                    if (this.particles.length >= this.maxParticles) {
                        this.particles.shift();
                    }

                    this.particles.push({
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 2,
                            Math.random() * 2
                        ),
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.02
                    });
                }
            }

            update() {
                const positions = this.mesh.geometry.attributes.position.array;
                const alphas = this.mesh.geometry.attributes.alpha.array;

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.position.add(p.velocity);
                    p.velocity.multiplyScalar(0.98);
                    p.life -= p.decay;

                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }

                // Update buffers
                for (let i = 0; i < this.maxParticles; i++) {
                    if (i < this.particles.length) {
                        const p = this.particles[i];
                        positions[i * 3] = p.position.x;
                        positions[i * 3 + 1] = p.position.y;
                        positions[i * 3 + 2] = p.position.z;
                        alphas[i] = p.life;
                    } else {
                        positions[i * 3] = 0;
                        positions[i * 3 + 1] = 0;
                        positions[i * 3 + 2] = -1000;
                        alphas[i] = 0;
                    }
                }

                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.geometry.attributes.alpha.needsUpdate = true;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CARD OBJECT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        class Card3D {
            constructor(data, index, total) {
                this.data = data;
                this.index = index;

                // Create geometry
                const geometry = new THREE.PlaneGeometry(16, 10, 32, 32);

                // Create material
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uHover: { value: 0 },
                        uSelected: { value: 0 },
                        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                        uColor: { value: CONFIG.colors.brand },
                        uAccentColor: { value: CONFIG.colors.accent }
                    },
                    vertexShader: cardVertexShader,
                    fragmentShader: cardFragmentShader,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(geometry, this.material);

                // Position in grid
                const cols = 2;
                const row = Math.floor(index / cols);
                const col = index % cols;
                const offsetX = (cols - 1) * 10;
                const offsetY = (Math.ceil(total / cols) - 1) * 7;

                this.restPosition = new THREE.Vector3(
                    col * 20 - offsetX,
                    -row * 14 + offsetY,
                    0
                );

                this.mesh.position.copy(this.restPosition);

                // Physics state
                this.velocity = new THREE.Vector3();
                this.isDragging = false;
                this.isHovered = false;

                // Create HTML label
                this.createLabel();
            }

            createLabel() {
                const container = document.getElementById('card-labels');

                const label = document.createElement('div');
                label.className = 'card-label';
                label.id = `label-${this.data.id}`;
                label.innerHTML = `
                    <div class="card-label-inner">
                        <span class="card-status ${this.data.status === 'live' ? 'status-live' : 'status-coming'}">
                            ${this.data.status === 'live' ? 'Live' : 'Coming'}
                        </span>
                        <div class="card-category">${this.data.category}</div>
                        <h3 class="card-title">${this.data.title}</h3>
                        <p class="card-description">${this.data.description}</p>
                        <div class="card-tech">
                            ${this.data.tech.map(t => `<span class="tech-tag">${t}</span>`).join('')}
                        </div>
                        ${this.data.url
                            ? `<a href="${this.data.url}" class="card-link" target="_blank">Launch &rarr;</a>`
                            : `<span class="card-link card-link-disabled">Coming Soon</span>`
                        }
                    </div>
                `;

                container.appendChild(label);
                this.labelElement = label;
            }

            updateLabel(camera) {
                // Project 3D position to 2D screen coordinates
                const pos = this.mesh.position.clone();
                pos.project(camera);

                // Convert NDC (-1 to 1) to screen pixels
                // Use window dimensions, not canvas (which is scaled by devicePixelRatio)
                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

                // Position label (centered via CSS transform)
                this.labelElement.style.left = `${x}px`;
                this.labelElement.style.top = `${y}px`;

                // Scale based on distance (z in NDC space is 0-1 for visible)
                const depth = Math.max(0, Math.min(1, pos.z));
                const scale = 1.0 - depth * 0.2;

                // Apply transform for centering and scaling
                this.labelElement.style.transform = `translate(-50%, -50%) scale(${scale})`;

                // Opacity based on visibility (hide if behind camera)
                this.labelElement.style.opacity = pos.z < 1 ? 1 : 0;
            }

            update(time, mouseWorld) {
                // Update uniforms
                this.material.uniforms.uTime.value = time;
                this.material.uniforms.uHover.value += (this.isHovered ? 1 : 0 - this.material.uniforms.uHover.value) * 0.1;

                if (!this.isDragging) {
                    // Spring back to rest position
                    const restForce = this.restPosition.clone().sub(this.mesh.position).multiplyScalar(0.05);
                    this.velocity.add(restForce);

                    // Apply velocity
                    this.velocity.multiplyScalar(CONFIG.physics.damping);
                    this.mesh.position.add(this.velocity);
                }
            }

            startDrag() {
                this.isDragging = true;
                this.material.uniforms.uSelected.value = 1;
            }

            endDrag(throwVelocity) {
                this.isDragging = false;
                this.material.uniforms.uSelected.value = 0;
                this.velocity.copy(throwVelocity.multiplyScalar(CONFIG.physics.throwMultiplier));
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MAIN APPLICATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        class CyberKineticLabs {
            constructor() {
                this.canvas = document.getElementById('webgl-canvas');
                this.mouse = new THREE.Vector2(0.5, 0.5);
                this.mouseWorld = new THREE.Vector3();
                this.prevMouse = new THREE.Vector2();
                this.mouseVelocity = new THREE.Vector2();
                this.raycaster = new THREE.Raycaster();
                this.cards = [];
                this.draggedCard = null;
                this.dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                this.dragOffset = new THREE.Vector3();
                this.clock = new THREE.Clock();

                this.init();
            }

            init() {
                this.setupRenderer();
                this.setupScene();
                this.setupCamera();
                this.setupLights();
                this.setupGrid();
                this.setupCards();
                this.setupParticles();
                this.setupPostProcessing();
                this.setupEventListeners();
                this.hideLoading();
                this.animate();
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setClearColor(CONFIG.colors.void, 1);
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(CONFIG.colors.void, 50, 150);
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    50,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    200
                );
                this.camera.position.z = 60;
            }

            setupLights() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.3);
                this.scene.add(ambient);

                const point1 = new THREE.PointLight(CONFIG.colors.brand, 1, 100);
                point1.position.set(30, 30, 30);
                this.scene.add(point1);

                const point2 = new THREE.PointLight(CONFIG.colors.accent, 0.5, 100);
                point2.position.set(-30, -30, 20);
                this.scene.add(point2);
            }

            setupGrid() {
                const { count, spacing, depth } = CONFIG.grid;
                const total = count * count;

                // Base geometry
                const baseGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const geometry = new THREE.InstancedBufferGeometry();
                geometry.index = baseGeometry.index;
                geometry.attributes.position = baseGeometry.attributes.position;
                geometry.attributes.normal = baseGeometry.attributes.normal;

                // Instance attributes
                const offsets = new Float32Array(total * 3);
                const randoms = new Float32Array(total);

                for (let i = 0; i < count; i++) {
                    for (let j = 0; j < count; j++) {
                        const idx = i * count + j;
                        offsets[idx * 3] = (i - count / 2) * spacing;
                        offsets[idx * 3 + 1] = (j - count / 2) * spacing;
                        offsets[idx * 3 + 2] = depth;
                        randoms[idx] = Math.random();
                    }
                }

                geometry.setAttribute('aOffset', new THREE.InstancedBufferAttribute(offsets, 3));
                geometry.setAttribute('aRandom', new THREE.InstancedBufferAttribute(randoms, 1));

                // Material
                this.gridMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                        uMouseRadius: { value: 20 },
                        uColor: { value: CONFIG.colors.brand },
                        uAccentColor: { value: CONFIG.colors.accent }
                    },
                    vertexShader: gridVertexShader,
                    fragmentShader: gridFragmentShader,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.gridMesh = new THREE.Mesh(geometry, this.gridMaterial);
                this.gridMesh.frustumCulled = false;
                this.scene.add(this.gridMesh);
            }

            setupCards() {
                CONFIG.cards.forEach((cardData, index) => {
                    const card = new Card3D(cardData, index, CONFIG.cards.length);
                    this.cards.push(card);
                    this.scene.add(card.mesh);
                });
            }

            setupParticles() {
                this.particleEmitter = new ParticleEmitter(this.scene, CONFIG.colors.brand);
            }

            setupPostProcessing() {
                this.composer = new EffectComposer(this.renderer);

                const renderPass = new RenderPass(this.scene, this.camera);
                this.composer.addPass(renderPass);

                const bloomPass = new UnrealBloomPass(
                    new THREE.Vector2(window.innerWidth, window.innerHeight),
                    0.8,    // strength
                    0.4,    // radius
                    0.85    // threshold
                );
                this.composer.addPass(bloomPass);
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mouseup', (e) => this.onMouseUp(e));

                // Touch support
                window.addEventListener('touchstart', (e) => this.onTouchStart(e));
                window.addEventListener('touchmove', (e) => this.onTouchMove(e));
                window.addEventListener('touchend', (e) => this.onTouchEnd(e));
            }

            onResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();

                this.renderer.setSize(width, height);
                this.composer.setSize(width, height);
            }

            onMouseMove(e) {
                this.prevMouse.copy(this.mouse);

                this.mouse.x = e.clientX / window.innerWidth;
                this.mouse.y = e.clientY / window.innerHeight;

                this.mouseVelocity.set(
                    this.mouse.x - this.prevMouse.x,
                    this.mouse.y - this.prevMouse.y
                );

                // Update grid uniform
                this.gridMaterial.uniforms.uMouse.value.copy(this.mouse);

                // Raycasting for hover
                const mouseNDC = new THREE.Vector2(
                    this.mouse.x * 2 - 1,
                    -(this.mouse.y * 2 - 1)
                );

                this.raycaster.setFromCamera(mouseNDC, this.camera);

                // Check card intersections
                const cardMeshes = this.cards.map(c => c.mesh);
                const intersects = this.raycaster.intersectObjects(cardMeshes);

                this.cards.forEach(card => {
                    card.isHovered = false;
                });

                if (intersects.length > 0) {
                    const card = this.cards.find(c => c.mesh === intersects[0].object);
                    if (card) {
                        card.isHovered = true;
                        card.material.uniforms.uMouse.value.copy(intersects[0].uv);
                    }
                }

                // Drag
                if (this.draggedCard) {
                    const intersection = new THREE.Vector3();
                    this.raycaster.ray.intersectPlane(this.dragPlane, intersection);

                    if (intersection) {
                        this.draggedCard.mesh.position.copy(intersection.sub(this.dragOffset));

                        // Emit particles while dragging
                        if (Math.random() > 0.7) {
                            this.particleEmitter.emit(this.draggedCard.mesh.position, 2);
                        }
                    }
                }
            }

            onMouseDown(e) {
                const mouseNDC = new THREE.Vector2(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );

                this.raycaster.setFromCamera(mouseNDC, this.camera);

                const cardMeshes = this.cards.map(c => c.mesh);
                const intersects = this.raycaster.intersectObjects(cardMeshes);

                if (intersects.length > 0) {
                    const card = this.cards.find(c => c.mesh === intersects[0].object);
                    if (card) {
                        this.draggedCard = card;
                        card.startDrag();

                        // Calculate drag offset
                        this.dragPlane.setFromNormalAndCoplanarPoint(
                            new THREE.Vector3(0, 0, 1),
                            card.mesh.position
                        );

                        const intersection = new THREE.Vector3();
                        this.raycaster.ray.intersectPlane(this.dragPlane, intersection);
                        this.dragOffset.copy(intersection).sub(card.mesh.position);

                        // Burst particles
                        this.particleEmitter.emit(card.mesh.position, 20);
                    }
                }
            }

            onMouseUp(e) {
                if (this.draggedCard) {
                    const throwVelocity = new THREE.Vector3(
                        this.mouseVelocity.x * 100,
                        -this.mouseVelocity.y * 100,
                        0
                    );

                    this.draggedCard.endDrag(throwVelocity);

                    // Release burst
                    this.particleEmitter.emit(this.draggedCard.mesh.position, 30);

                    this.draggedCard = null;
                }
            }

            onTouchStart(e) {
                if (e.touches.length > 0) {
                    this.onMouseDown({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    });
                }
            }

            onTouchMove(e) {
                if (e.touches.length > 0) {
                    e.preventDefault();
                    this.onMouseMove({
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    });
                }
            }

            onTouchEnd(e) {
                this.onMouseUp({});
            }

            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 500);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                // Update grid
                this.gridMaterial.uniforms.uTime.value = time;

                // Update cards
                this.cards.forEach(card => {
                    card.update(time, this.mouseWorld);
                    card.updateLabel(this.camera);
                });

                // Update particles
                this.particleEmitter.update();

                // Subtle camera movement
                this.camera.position.x += (this.mouse.x * 4 - 2 - this.camera.position.x) * 0.02;
                this.camera.position.y += (-this.mouse.y * 4 + 2 - this.camera.position.y) * 0.02;
                this.camera.lookAt(0, 0, 0);

                // Render
                this.composer.render();
            }
        }

        // Initialize
        new CyberKineticLabs();
    </script>
</body>
</html>
